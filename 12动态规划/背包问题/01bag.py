"""
今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题。描述：
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

举个简单的例子，输入如下：
N = 3, W = 4
wt = [2, 1, 3]
val = [4, 2, 3]
算法返回 6，选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6。


第一步要明确两点，「状态」和「选择」。

每做一次选择，状态都会改变
先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。所以状态有两个，就是「背包的容量」和「可选择的物品」。
再说选择，也很容易想到啊，对于每件物品，你能选择什么？选择就是「装进背包」或者「不装进背包」嘛。

第二步要明确 dp 数组的定义。
首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 dp 数组。
dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。
比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。
"""


def knapsack(N, W, wt, val):
    # N表示物品个数，W表示背包容量，wt表示每个物品第i个物品的重量数组，val表示第i个物品的价值
    # 【状态】：物品个数、背包容量
    # 【选择】： 装进背包/不装进背包
    dp = [[0] * (W+1) for _ in range(N+1)]
    for i in range(1, N+1):
        for w in range(1, W+1):
            if w - wt[i-1] < 0:  # 再放进去就超过容量了
                dp[i][w] = dp[i-1][w]
            else:  # 不超过容量
                # 2个选择，装或者不装
                dp[i][w] = max(
                    dp[i-1][w], # 不装
                    dp[i-1][w-wt[i-1]] + val[i-1]) # 装进背包
    return dp[N][W]


N = 3
W = 4
wt = [2, 1, 3]
val = [4, 2, 3]

res = knapsack(N, W, wt, val)
print(res)
